# 游戏核心代码  
	函数 IsA（ClassName::StaticClass()）   ---判断对象的类型
	# AdpGameMode 在里面做初始化
	dpUEdEngine   editor用的
		UdpEnData* _UspEnData;  全局的游戏数据加载，
	
	dPGameEngine  Game用的
		UdpEnData* _UspEnData;  全局的游戏数据加载，还有系统的管理器
		Init()    及时加载
		InitManual()  初始化对应的数据 _UspEnData  延迟加载
			SetGameMode()  设置用到的 GameMode
			bindGame()  
			
			UdpLoginManager  
				登录管理器 初始数据的接口 InitCheckAndloadGame() --> loadLastLoginPlayer()
		AdpGameGameMode   类似于GameInfo
			BeginPlay（）  
				InitialGame()  ---初始化游戏逻辑
	
	#dpGameGameMode  游戏的逻辑控制 GameMode
		PostLogin()  --> BeginPlay()
		
		
		
		
		
			
	# AdpLoginGameMode    登录的逻辑管理器    介入点  
	UGameInstance::StartPIEGameInstance() -->
	ULocalPlayer::SpawnPlayActor() --> LevelActor::SpawnPlayActor(0s
		
		PostLogin()  --> BeginPlay()
		
		showScene() --> GetNextMapName()
		
		setLoginMode()
		
		initialLoginUI()  界面打开后延迟执行
		
		
	# TSharedPtr   共享指针
		创建方法 
			struct MyStruct
			{
				int a; 
			};
			TSharedPtr<MyStruct> pTr = MakeShareable(new MyStruct());
			pTr.a = 0;
			
	
	
# AdpNpcPawn
	BeginPlay() --> InitEnemy()  有可能会延迟执行 --> 
	

# UdpGamePlayer   在PlayerController里面做调用角色数据的接口

# _UspEnData_GameRef  UdpEnData  全局数据的对象引用

# UFUNCTION(exec) 启用命令行来调用函数 调用的自身对应的成员函数 比如
	UFUNCTION(exec)
	void showScene(bool show);
	"showScene true"
	
# 计时器 
	GetWorldTimerManager().SetTimer(TimerHandle_delaypostInitialGame, this, &AdpGameGameMode::delaypostInitialGame, 3.0f, false);
# FText 
	FText::Format( LOCTEXT( "HealthFormatStr",  "{0} / {1}" ), FText::AsNumber( CurrentHealth ), FText::AsNumber( MaxHealth )  ) 
	
	FString pBtnName_UI = FString::Printf(TEXT("Text_Btn%d"), i + 1);
	
#日志的打印
	GLog->Logf(TEXT("ERROR!! Server have get a code %d, %s"), 0, aErr.GetCharArray().GetData());
	打印到屏幕上
		GEngine->AddOnScreenDebugMessage(1, 2, FColor::Green, FString::Printf(TEXT("[UdpNetManager::__dpProcessNetCb] Server have get a code %d %s"), int32(psErrorResp.code()), aErr.GetCharArray().GetData()));
	
	
# 注册用户点击输入的事件
  AdpLoginGameMode  里面
   //使用当前Touch Start 注册
		auto pInput = NewPlayer->InputComponent;
		pInput->BindTouch(EInputEvent::IE_Pressed, _LoginMrg, &ULoginMrg::OnTouchStart);
		pInput->BindTouch(EInputEvent::IE_Released, _LoginMrg, &ULoginMrg::OnTouchEnd);
		pInput->BindTouch(EInputEvent::IE_Repeat, _LoginMrg, &ULoginMrg::OnTouchMove);

# 刷怪触发器 dpGame\Content\Dragon\com\AI\spCycleSpwner_bp
# 怪物的AI  dpGame\Content\Dragon\com\AI\EnemyAI_BP


# 对象基类 
	UserClassSystemInterface 

	UObjSystemInterface

# 收发消息
	//支持 将 ParamTypes 打包成任意类型 
	TCMDMulticastDelegateGather_UFunctionPackageParams
		下属 TCMDMulticastDelegateGather_UFunction<TypeCMD , TypePackage> SuperClass;
	//支持 Obj....
	TCMDMulticastDelegateGather_UObjFunctionPackageParams
		下属 typedef TCMDMulticastDelegateGather_UObjFunction<TypeCMD, TypePackage> SuperClass;


# 生成对应的成员操作函数 Set Get 之类的函数
	PROPERTY_GS_PTR_DEFAULT
	PROPERTY_S_PTR_DEFAULT  PROPERTY_G_PTR_DEFAULT
	还有类似的 OBJ VAR

# 数据读写的操作码 FlagOp

# 广播消息的回调注册操作
	声明 NETNOTIFY_DECLAREFUNC  定义 NETNOTIFY_DECLARECLASSFUNC

# 单例的引用 
	typedef NS_GameFuction::TGameArray<...> GameCache
	利用内存的分配机制
	FMemory::Malloc(SizeClass::Size()))  FMemory::Memzero(Ptr, SizeClass::Size())
	然后传出 TSharedPtr<TGameArray<ParamTypes...>>

	获取单例的对象
		GetCache()->Get<CacheIdx_UdpNetManager>().Get()
	注册单例的对象
		

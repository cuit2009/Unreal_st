* 需求
	* 两个编辑器
		//DragonProject/DesignDoc/19.编辑器需求/角色编辑器.docx
			* 角色 
				* 需求内容 
					* 已有的角色 
						* 列出已经创建好的角色 
					* 新建角色
						* 分配ID
						* 指定模型
							* 模型指定之后会把指定的模型路径写入配置
							* 编辑器运行时，会根据配置中的模型路径动态加载模型
						* 如何测试？
							* 本地读取配置表进行测试好不好？
								* 大多数情况下，可以的，能够立刻得到配置正确与否的反馈
				* 开发时间
					* 编辑器
						* 2 day
					* 运行时
						* 动态加载角色数据 1 day
			* 动作
				* 开发时间
					* 动作列表	
						* 功能点
							* 扩展编辑器	3 day
							* 访问并显示特定目录中的动画文件 1 day
							
					* 动作选定之后，轨道容器中会显示该动作的编辑数据
						* 功能点
							* 扩展编辑器	3 day
							* 数据显示和编辑 	3 day
					* 美术数据与策划的逻辑数据分离 4 day						
					* 非绑定型动画通知	6 day
						* 功能点
							* NoneAttachActor 实现
					* 跟踪类型的只需要扩展一种tick时朝目标移动的动画通知 3 day
					* 特定通知开发
						* 震动参数配置	1 day
						* 打断配置		2 day
						* 压黑效果配置	1 day
						* 循环帧配置	2 day
				* 需求内容
					* 动作列表：
						选择创建好的角色，能够自动显示该角色对应的所有动作
						* 选择角色后，由于配置中已经有该模型对应资源，所以可以根据模型过滤出使用该模型的所有资源，可以有两种做法：
							* 美术把资源放到特定文件夹中，程序根据命名规则自动索引该文件夹中的所有动作资源
							* 根据资源的引用关系找到该资源的路径
								* 这个有待测试
					* 动作选定之后，轨道容器中会显示该动作的编辑数据
						* 选定操作会根据动作查找对应的配置中的技能数据，如果是编辑过的动作，会有各种逻辑编辑数据会被加载到轨道上
							* 要把美术数据与策划的逻辑数据分离开，避免耦合
								* 所有逻辑数据都会写入配置，而美术数据不会写入配置
									* 可以考虑所有逻辑相关的动画通知都从一个 dpNotify/dpStateNotify 基类派生，这个维护了配置性，
										在读取和保存有这个基类派生的所有类时，都是走特殊的流程。
										* 读取： 
											* 从配置读取并初始化动作序列时创建
												* 即便美术更新了动作，都不会影响到策划的配置数据
										* 保存:
											* 在保存时，所有dp基类的派生类都不会序列化到磁盘，只会写入配置
						* 参数配置
							* 就采用现有的动画通知机制就行，只需要扩展我们需要的动画通知
						* 绑定和非绑定动画通知
							* 绑定型动画通知
							* 非绑定型动画通知
								* 动作及发射特效（非绑定特效）的创建
									* 考虑参考特效的实现方式，实现另一种动画通知
										* 动画通知触发后，会创建一个 NoneAttachActor ，这个会维护如下数据及逻辑:
											* 数据
												* SkeletalMesh
												* 动作
											* 逻辑
												* 动画通知触发后，spawn 这个 NoneAttachActor ，并且 play 这个 NoneAttachActor 配置的动画
												* 伤害检测还是使用相同统一的方式计算
										* 好处
											* 可以模拟出大多数想要的技能
											* 伤害检测和表现都十分可控	
								* 跟踪类型的只需要扩展一种tick时朝目标移动的动画通知
									* 数据
										* isTrack
										* 权重 0-100 跟踪算法的逼近权重， 0 是不跟踪， 100 是一次就完全逼近，中间是不同速率逐渐逼近
						* 其他
							* 动作配置参数
							* 绑定特效配置
							* 发射特效配置
							* 音效配置
							* 攻击定义配置
								1.	攻击定义ID：参数类型1，同一个技能内攻击定义ID不能重复，用于配置表调用攻击定义信息。
								2.	攻击帧插入时间：参数类型1，代表该攻击帧在动作播放时的产生时间。修改该参数时对应的帧在进度条的位置会发生改变，单位毫秒。
								3.	受击特效：参数类型2，选择工程目录内对应受击特效文件。用于技能攻击目标时，目标的受击特效播放。
								4.	受击特效相对位置：参数类型5，填写受击特效相对于受击目标中心点的位置。
								5.	受击特效朝向：参数类型5，填写特效播放时的朝向角度。
								6.	卡帧时间：参数类型1，填写卡帧的时间，单位毫秒。
								7.	攻击体形状：参数类型4，选择攻击体形状，包含矩形和扇形两种形状。
								8.	攻击体大小：参数类型5，填写攻击体大小参数，若攻击体为矩形，则参数分别为矩形的长、宽、高。若攻击体为扇形，则参数分别为扇形半径、角度、高度。
								9.	攻击体相对位置：参数类型5，填写攻击体相对角色中心点的位置。
								10.	攻击体相对朝向：参数类型5，填写攻击体生效时的朝向。
							* 震动参数配置
							* 打断配置
							* 压黑效果配置
							* 循环帧配置
							* 
				* 开发时间
					* 
			* AI	
		//DragonProject/DesignDoc/19.编辑器需求/关卡编辑器.docx
			数据 //DragonProject/DesignDoc/06.关卡系统/场景规则.docx
			* 编辑物件统计及其数据	7 day
				4.1	复活点	
					MarkID
					位置
				4.2	飞行点
					MarkID
					位置
					路径点
						* 是否需要在编辑时显示路线？
				4.3	寻路点
					MarkID
					位置
					路径点
						* 是否需要在编辑时显示路线？
				4.4	传送点
					MarkID
					位置
				4.5	传送区
					MarkID
					位置
					旋转
					缩放
				4.6	安全区
					MarkID
					位置
					旋转
					缩放
				4.7	坐骑限制区
					MarkID
					位置
					旋转
					缩放
				4.8	区域分割标记
					MarkID
					位置
					旋转
					缩放
					碰撞
						碰撞模式
						碰撞体位置
						碰撞体旋转
						碰撞体缩放
				4.9	物件点
					MarkID
					位置
					初始状态
					刷新间隔
					对象配置
						对象的ID
						权重值
				4.10	怪物点
					MarkID
					位置
					初始状态
					刷新间隔
					对象配置
						对象ID
				4.11 NPC点
					MarkID
					位置
					初始状态
					刷新间隔
					对象配置
						对象ID
				4.12 空气墙/门
					MarkID
					初始状态
					位置
					旋转
					缩放
					碰撞
						碰撞模式
						碰撞体位置
						碰撞体旋转
						碰撞体缩放
					美术资源
				4.13 触发器
					MarkID
					初始状态
					位置
					旋转
					缩放
					碰撞
						碰撞模式
						碰撞体位置
						碰撞体旋转
						碰撞体缩放
					触发器的类型
					条件
					通知对象(ID)
			* 其他
				* 数据导出及本地测试	
					* 所有可编辑物件都会导出到配置表，并交给服务器录入	4 day
					* 本地测试	(需讨论是否可行，可行的情况下，时间成本为 5 day)
						* 是否需要本地测试？
							* 场景编辑器必须具有非常强的所见即所得以及快速的测试流程，满足策划对场景的快速迭代需求。
						* 实现本地测试的时间成本高不高？					
							* 数据修改后保存到配置表
							* 测试流程
								* 读取配置表
								* 触发器模拟服务器通知
									* 触发器触发相当于服务器通知
									* 数据从触发器数据中读取
				* 地图组织策略	4 day
					所有 可编辑物件 都不会在场景资源地图中，而是在另外的子关卡中，作用仅仅是用来产生服务器端需要的配置数据，最终发布版本中是不会打包这个子关卡的
					* 策划可以手动维护这种组织关系，也可以考虑程序自动实现
						* 关卡编辑器中应该有一个我们项目定制的 创建地图 的选项，执行之后，要求填入地图ID，在后台自动生成如下地图及其组织关系
							假设地图ID为 Castle_01,那么自动生成的地图如下：
							* 主关卡
								* 名字后缀 "_Entry" : 如 Castle_01_Entry
									* 后缀的好处是便于磁盘上按名字排列和检索，同一张地图的会排列到一块
								* 作用 : 负责该地图的实际调度
								* 要求 : 是一个空场景
								* 打包发布 : 是
							* 子关卡
								* 场景碰撞关卡
									* 名字后缀 "_Collision" : 如 Castle_01_Collision
									* 作用 : 负责存放碰撞数据，保证角色等动态Actor不会掉到地面以下
									* 特别说明 : 
										动态加载的Actor的加载时机应该是在 场景碰撞关卡 加载之后，
										以保证关卡中动态加载的Actor不会掉到地面以下
									* 要求 : 无
									* 打包发布 : 是
								* 逻辑编辑关卡
									* 名字后缀 "_Editor" : 如 Castle_01_Editor
									* 作用 : 负责存放产生最终配置数据的逻辑对象
									* 特别说明 :  
										逻辑编辑关卡 是不会打包的最终发布版中，因为其中的逻辑对象的作用仅仅是拿来产生配置数据的
									* 要求 : 无
									* 打包发布 : 是
								* 场景资源关卡
									* 名字后缀 "_Scene" : 如 Castle_01_Scene 
									* 作用 : 负责存放美术场景资源
									* 特别说明 : 
										由于场景资源量很大，加载时间比较长，采取的是异步加载的方式	
									* 要求 : 无
									* 打包发布 : 否																										
				* 地图碰撞数据的导出	7 day
					* 目的 : 导出地图碰撞信息，以便服务器进行AI寻路计算及是否可穿越校验
					* 实现 : 
						* 地编导出单地图碰撞数据
						* 地编导出所有地图碰撞数据
							* 需和服务器匹配地图分区策略
				
		
	* 其他
		* 战斗系统
			战斗规则完全实现（包含各种动作状态及索敌规则等）
				* 普通攻击	1 day
					* 配置化
				* 特殊攻击	3 day
					* 配置化
					* CD时间
			数值框架完成（包含属性类型定义、战斗公式、状态判定等） 2 day
				* 配置化
			技能系统框架完成（包含技能类型、伤害计算等）	
				* 配置化
			角色自动战斗功能（包含目标寻找与自动攻击）
				* 战斗寻路	2 day
					* 大于冲刺距离，自动跑向敌人
				* 靠近敌人自动冲刺	2 day
					* 小于冲刺距离
						* 索敌并跑动过程中，一旦距离小于冲刺距离，即使没有按下工具键，都会触发冲刺状态
				* 自动战斗逻辑	2 day
					* 与敌人距离小于攻击范围，展开攻击				
			变身状态功能实现（玩家可以变身为机甲状态进行战斗） 1 day
				* 配置化
			怪物系统基本完成（包含怪物数值、刷怪机制）	3 day
				* 配置化
					怪物数据表导出及测试
			NPC AI（包含索敌、移动、攻击）	
				* 客户端： 配置化	3 day
				* 服务器实现	（时间 需服务器确定）
					* AI状态管理
					* AI寻路算法
			场景内掉落功能完成，掉落拾取功能完成 
				* 客户端		2 day
					* 掉落表现
					* 拾取表现
					* 
				* 服务器
					* 掉落逻辑
					* 拾取逻辑
				* 注意： 掉落应该和任务系统一块，才能形成闭环
		* 成长系统
			角色基础实现（角色升级、属性、信息参数等）	3 day
				* 客户端UI表现
				* 服务器数据及逻辑
			装备基础功能实现（装备穿脱、装备基础属性）	2 day
				* 客户端UI表现
				* 服务器数据及逻辑
			装备强化功能实现	2 day
				* 客户端UI表现
					* 侧重服务器数据的表现，没有UI的完整实现
				* 服务器数据及逻辑
			装备打造功能实现	2 day
				* 客户端UI表现
					* 侧重服务器数据的表现，没有UI的完整实现
				* 服务器数据及逻辑
			变身升阶功能实现（升阶后改变持有武器外形和属性）	2 day
				* 客户端UI表现
					* 侧重服务器数据的表现，没有UI的完整实现
				* 服务器数据及逻辑
			坐骑升阶功能实现（升阶后改变坐骑外形和属性）	2 day
				* 客户端UI表现
					* 侧重服务器数据的表现，没有UI的完整实现
				* 服务器数据及逻辑
			翅膀升阶功能实现（升阶后改变翅膀外形和属性）	2 day
				* 客户端UI表现
					* 侧重服务器数据的表现，没有UI的完整实现
				* 服务器数据及逻辑
		* 玩法与内容
			诸神之战场景打磨（场景布局优化、加入过场动画，丰富表现手段）
			主线任务基本功能完成（交接任务、NPC对话、自动寻路、界面）
				* 交接任务, NPC对话	3 day
				* 界面数据显示	2 day
				* 自动寻路	3 day															
			场景内飞行功能完成	3 day
				* 客户端剧情表现
				* 服务器数据及逻辑
			跨场景传送门功能完成(走到传送门上进入下一个场景）	1 day
				* 客户端场景调度
				* 服务器数据及逻辑
			简单副本功能实现（资源副本、BOSS副本）	2 day
				* 客户端场景调度
					* 客户端简单处理，能进场景打打怪
				* 服务器数据及逻辑
			道具系统基本功能完成（包含背包功能、奖励发放规则、道具使用） 7 day
				* 客户端UI表现	
					* 图标显示，数量
					* 使用消耗
				* 服务器数据及逻辑
		* 辅助功能
			小地图功能	3 day
				* 地图拼接
				* 服务器同步
				* 客户端小地图显示
					* 只做显示
			地图寻路功能	4 day				
			其他
			账号与登陆流程（测试流程跑通）	1.5 day	
				配置流程
			选角、创角流程	1.5 day
				配置流程
			外网测试服务器搭建
	* 全面配置化+动态加载	（上面已经包含）
		* 场景调度
		* 角色
		* 技能
	* 代码重构	7 day
		* 临时代码处理
		* 抽象及模块化
	* 封装策略	3 day
		* 权限方案：
			* 核心人员才有权访问所有代码
			* 不是所有人都有打包权限，应该是核心人员，有访问所有代码的人员
			* 对非核心人员而言，项目中只开放windows库的权限，移动库不开放
		* 实现及摸索	
	* 战斗及技能完善	（角色技能已经搞定）
		* 角色编辑器中处理了相应的配置及逻辑数据
		* 与服务器联调
	* AI及场景可穿越校验	
		* NPC服务器AI实现
		* 场景可穿越校验
			* 客户端地图数据导出（上面已有 地图碰撞数据的导出）
			* 服务器校验算法
			
* 时间统计
	7+4+5+4+7+2+1+3+1+3+3+4+6+3+1+2+1+2+1+3+2+2+2+2+1+3+3+2+3+2+2+2+2+2+2+3+2+3+3+1+2+7+3+4+1.5+1.5+7+3 = 136 工作日
	加 8 个周末 = 136+8 = 144
* 人手
	按5个客户端算 
	工作量分配
		陈 60 
		余 40
		黎 20
		宋 10
		60+40+20+10=130
		其他 144-130=14
	